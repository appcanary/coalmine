require 'test_helper'
class VulnerabilityManagerTest < ActiveSupport::TestCase
  self.use_transactional_fixtures = false

  after :each do
    DatabaseCleaner.clean
  end

  test "right_join_coll should do the right thing" do
    vm = VulnerabilityManager.new(Platforms::Ruby)

    klass = Struct.new(:id, :foo, :bar) do
      def unique_hash
        {:foo => foo, :bar => bar}
      end
    end

    # we create an array of 5 existing objects

    existing = 5.times.map do |i| 
      klass.new(i, i + 1, i * i)
    end

    # which will look like this
    #<struct  id=0, foo=1, bar=0>,
    #<struct  id=1, foo=2, bar=1>,
    #<struct  id=2, foo=3, bar=4>,
    #<struct  id=3, foo=4, bar=9>,
    #<struct  id=4, foo=5, bar=16>

    # we then create a 'new' array of 2 'new' objects
    # that match preceeding array, but have id of nil
    # and one entirely new object
    new = [klass.new(nil, 3, 4),
           klass.new(nil, 4, 9),
           klass.new(nil, 10, 10)]

    diffed = vm.right_join_coll(existing, new)

    assert_equal 3, diffed.count
    assert_equal 2, diffed[0].id, "should actually be object from existing"
    assert_equal 3, diffed[1].id, "should actually be object from existing"
    assert_equal nil, diffed[2].id, "should be new object"

    ## okay. what about if the new array is empty?

    diffed2 = vm.right_join_coll(existing, [])
    assert_equal [], diffed2

    ## what if the first array is empty?
    diffed3 = vm.right_join_coll([], new)
    assert_equal new, diffed3

    # what if there is nothing in common?
    new2 = [klass.new(10, 100, 100)]

    diffed4 = vm.right_join_coll(existing, new2)
    assert_equal new2, diffed4

    # what if there is a dupe?
    new3 = [klass.new(10, 100, 100),
            klass.new(11, 100, 100)]

    diffed5 = vm.right_join_coll(existing, new3)
    assert_equal 1, diffed5.count

  end

  test "upon new vuln, should update affected packages" do
    pkg_name = "fakemctest"
    10.times do |i|
      FactoryGirl.create(:package, :ruby,
                         :name => pkg_name,
                         :version => "1.0.#{i}")
    end

    assert_equal 10, Package.count
    assert_equal 0, VulnerablePackage.count
    vm = VulnerabilityManager.new(Platforms::Ruby)

    adv = FactoryGirl.create(:advisory, :ruby, :constraints => 
                              [{:package_name => pkg_name, 
                                :patched_versions => ["> 1.0.4"]}])

    vuln, error = vm.create(adv)

    assert_equal 1, Vulnerability.count
    assert_equal 5, vuln.packages.count

    FactoryGirl.create(:vulnerability)

    assert_equal 2, Vulnerability.count
    assert_equal 5, VulnerablePackage.count
  end

  
  test "handle updates to existing vulnerabilities" do
    pkg_name = "fakemctest"
  
    10.times do |i|
      FactoryGirl.create(:package, :ruby,
                         :name => pkg_name,
                         :version => "1.0.#{i}")

    end

    assert_equal 10, Package.count
    assert_equal 0, VulnerablePackage.count

    vm = VulnerabilityManager.new(Platforms::Ruby)
    adv = FactoryGirl.create(:advisory, :ruby, :constraints => 
                             [{:package_name => pkg_name,
                              :patched_versions => ["> 1.0.1"]}])

    vuln, error = vm.create(adv)

    assert_equal 2, VulnerablePackage.count

    adv = FactoryGirl.create(:advisory, :ruby, 
                             :title => "OMG SERIOUS!",
                             :constraints => 
                              [{:package_name => pkg_name, 
                                :patched_versions => ["> 1.0.4"]}])


    # but actually turns out the bug was more severe than we first thought!!
    updated_vuln, error = vm.update(vuln, adv)


    assert updated_vuln.is_a? Vulnerability
    assert_equal updated_vuln.id, vuln.id
    assert_equal 5, VulnerablePackage.count
    assert_equal 1, VulnerabilityArchive.count

    # however after much research and investigation, 
    # someone made a mistake and the vuln versions are much smaller!
    adv = FactoryGirl.create(:advisory, :ruby, :title => "Actually less hateful",
                             :constraints => 
                              [{:package_name => pkg_name, 
                                :patched_versions => ["> 1.0.0"]}])


    vm.update(vuln, adv)

    assert_equal 1, VulnerablePackage.count
    assert_equal 2, VulnerabilityArchive.count
  end

  test "create vulnerability archives when vulnerable dependencies are added" do
    vm = VulnerabilityManager.new(Platforms::Ruby)
    adv = FactoryGirl.create(:advisory, :ruby,
                             :title => "Vuln")

    vuln, error = vm.create(adv)

    assert_equal 0, VulnerableDependency.count
    assert_equal 0, vuln.archives.count

    adv = FactoryGirl.create(:advisory, :ruby, 
                             :title => "Vuln",
                             :constraints => 
                             [{:package_name => "package", 
                               :patched_versions => ["> 1.0.4"]}])

    updated_vuln, err = vm.update(vuln, adv)
    assert_equal 1, VulnerableDependency.count
    assert_equal 1, updated_vuln.archives.count
  end


  test "when a constraint pending flag changes, update instead of deleting the vuln dep" do

    # let's suppose we have a bundle with some packages
    bundle = FactoryGirl.create(:bundle_with_packages, 
                                :platform => "ruby")

    p1name = bundle.packages.first.name
    p2name = bundle.packages.second.name

    assert_equal 0, VulnerableDependency.count

    # --- 
    # so, a new advisory comes in

    # sometimes, we get advisory info that notes
    # that a package is pending
    constraint1 = {:package_name => p1name,
     :patched_versions => ["> 99.0.1"],
     :pending => true}

    constraint2 = {:package_name => p2name,
     :patched_versions => ["> 99.0.1"]}


    vm = VulnerabilityManager.new(Platforms::Ruby)
    adv = FactoryGirl.create(:advisory, :ruby, :constraints => 
                             [constraint1, constraint2])

    vuln, error = vm.create(adv)

    assert_equal 2, VulnerableDependency.count
    
    p1_dep = VulnerableDependency.where(:package_name => p1name).first
    assert p1_dep.pending

    LogMakerJob.enqueue
    # we have two vuln packages, so:
    assert_equal 2, LogBundleVulnerability.count
    assert_equal 0, LogBundlePatch.count

    # ---
    # so far so dandy.
    # pending means that a fix has been identified and packaged
    # but is not yet available.
    
    # eventually it will become available and pending turns to false

    newconstraint1 = constraint1.dup.tap { |hsh| hsh[:pending] = false }
    updated_adv = FactoryGirl.create(:advisory, :ruby, :constraints => 
                                     [newconstraint1, constraint2])


    vm.update(vuln, updated_adv)
    assert_equal 2, VulnerableDependency.count
    
    # but.. the only thing we changed was the pending flag.
    # we should not have triggered any new logs
    LogMakerJob.enqueue
    assert_equal 2, LogBundleVulnerability.count
    assert_equal 0, LogBundlePatch.count

    
    # the trick here is that this should update the VulnDep
    # instead of deleting it and creating a new one
    # if we delete it, we'll trigger new LBPs and LBVs
    new_p1_dep = VulnerableDependency.where(:package_name => p1name).first
    assert_equal p1_dep.id, new_p1_dep.id
    assert_not new_p1_dep.pending

    # but oh no, p2 got end of lifed
    # 
    p2_dep = VulnerableDependency.where(:package_name => p2name).first
    assert_not p2_dep.end_of_life

    newconstraint2 = constraint2.dup.tap { |hsh| hsh[:end_of_life] = true }
    updated_adv = FactoryGirl.create(:advisory, :ruby, :constraints => 
                                      [newconstraint1, newconstraint2])

    vm.update(vuln, updated_adv)

    # same deal as above: no new vulns, no patches
    # and the actual id has not changed
    LogMakerJob.enqueue
    assert_equal 2, LogBundleVulnerability.count
    assert_equal 0, LogBundlePatch.count

    assert_equal 2, VulnerableDependency.count

    new_p2_dep = VulnerableDependency.where(:package_name => p2name).first
    assert_equal p2_dep.id, new_p2_dep.id
    assert new_p2_dep.end_of_life
  end

end
