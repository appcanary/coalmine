require 'test_helper'
class VulnerabilityManagerTest < ActiveSupport::TestCase
  self.use_transactional_fixtures = false

  after :each do
    DatabaseCleaner.clean
  end

  test "right_join_coll should do the right thing" do
    vm = VulnerabilityManager.new(Platforms::Ruby)

    klass = Struct.new(:id, :foo, :bar) do
      def unique_hash
        {:foo => foo, :bar => bar}
      end
    end

    # we create an array of 5 existing objects

    existing = 5.times.map do |i| 
      klass.new(i, i + 1, i * i)
    end

    # which will look like this
    #<struct  id=0, foo=1, bar=0>,
    #<struct  id=1, foo=2, bar=1>,
    #<struct  id=2, foo=3, bar=4>,
    #<struct  id=3, foo=4, bar=9>,
    #<struct  id=4, foo=5, bar=16>

    # we then create a 'new' array of 2 'new' objects
    # that match preceeding array, but have id of nil
    # and one entirely new object
    new = [klass.new(nil, 3, 4),
           klass.new(nil, 4, 9),
           klass.new(nil, 10, 10)]

    diffed = vm.right_join_coll(existing, new)

    assert_equal 3, diffed.count
    assert_equal 2, diffed[0].id, "should actually be object from existing"
    assert_equal 3, diffed[1].id, "should actually be object from existing"
    assert_equal nil, diffed[2].id, "should be new object"

    ## okay. what about if the new array is empty?

    diffed2 = vm.right_join_coll(existing, [])
    assert_equal [], diffed2

    ## what if the first array is empty?
    diffed3 = vm.right_join_coll([], new)
    assert_equal new, diffed3

    # what if there is nothing in common?
    new2 = [klass.new(10, 100, 100)]

    diffed4 = vm.right_join_coll(existing, new2)
    assert_equal new2, diffed4

    # what if there is a dupe?
    new3 = [klass.new(10, 100, 100),
            klass.new(11, 100, 100)]

    diffed5 = vm.right_join_coll(existing, new3)
    assert_equal 1, diffed5.count

  end

  test "upon new vuln, should update affected packages" do
    pkg_name = "fakemctest"
    10.times do |i|
      FactoryGirl.create(:package, :ruby,
                         :name => pkg_name,
                         :version => "1.0.#{i}")
    end

    assert_equal 10, Package.count
    assert_equal 0, VulnerablePackage.count
    vm = VulnerabilityManager.new(Platforms::Ruby)

    vuln, error = vm.create({},
                            [{:package_name => pkg_name,
                              :patched_versions => ["> 1.0.4"]}])

    assert_equal 1, Vulnerability.count
    assert_equal 5, vuln.packages.count

    FactoryGirl.create(:vulnerability)

    assert_equal 2, Vulnerability.count
    assert_equal 5, VulnerablePackage.count
  end

  
  test "handle updates to existing vulnerabilities" do
    pkg_name = "fakemctest"
  
    10.times do |i|
      FactoryGirl.create(:package, :ruby,
                         :name => pkg_name,
                         :version => "1.0.#{i}")

    end

    assert_equal 10, Package.count
    assert_equal 0, VulnerablePackage.count

    vm = VulnerabilityManager.new(Platforms::Ruby)

    vuln, error = vm.create({},
                            [{:package_name => pkg_name,
                              :patched_versions => ["> 1.0.1"]}])

    assert_equal 2, VulnerablePackage.count

    # but actually turns out the bug was more severe than we first thought!!
    updated_vuln, error = vm.update(vuln.id, {:title => "OMG SERIOUS!"},
                                    [{:package_name => pkg_name,
                                      :patched_versions => ["> 1.0.4"]}])


    assert updated_vuln.is_a? Vulnerability
    assert_equal updated_vuln.id, vuln.id
    assert_equal 5, VulnerablePackage.count
    assert_equal 1, VulnerabilityArchive.count

    # however after much research and investigation, 
    # someone made a mistake and the vuln versions are much smaller!

    vm.update(vuln.id, {:title => "Actually less hateful"},
              [{:package_name => pkg_name,
                :patched_versions => ["> 1.0.0"]}])

    assert_equal 1, VulnerablePackage.count
    assert_equal 2, VulnerabilityArchive.count
  end


end
