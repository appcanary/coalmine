# == Schema Information
#
# Table name: log_bundle_vulnerabilities
#
#  id                    :integer          not null, primary key
#  bundle_id             :integer
#  package_id            :integer
#  bundled_package_id    :integer
#  vulnerability_id      :integer
#  vulnerable_package_id :integer
#  created_at            :datetime         not null
#  updated_at            :datetime         not null
#

require 'test_helper'

class LogBundleVulnerabilityTest < ActiveSupport::TestCase

  let(:account) { FactoryGirl.create(:account) }

  setup do
    @platform = "ruby"
  end

  test "entire LBV lifecyle" do

    # ############
    # SCENARIO ONE
    # A bundle is created w/vuln packages
    # ############

    # let's create some packages
    pkgs = FactoryGirl.create_list(:ruby_package, 5)
    vuln_pkg = pkgs.first

    # and mark one of them as being vulnerable
    vuln = VulnerabilityManager.new.create(:package_name => vuln_pkg.name,
                                           :package_platform => vuln_pkg.platform,
                                           :patched_versions => ["> #{vuln_pkg.version}"])

    # making sure everything looks legit
    assert_equal 1, VulnerablePackage.count
    assert_equal 0, BundledPackage.count
    assert_equal 0, LogBundleVulnerability.count

    # then let's create a new bundle
    # and assign packages
    @bm = BundleManager.new(account)

    bundle = @bm.create({:platform => @platform}, 
                        pkgs.map { |p| {name: p.name, version: p.version}})

    assert_equal 1, bundle.vulnerable_packages.count
    assert_equal 1, LogBundleVulnerability.count

    # great. we created a bundle with a vuln package,
    # and we've confirmed that we registered that as a "log"
    #
    # OK. So what happens if we receive an update on the bundle?
    # The user throws in a bunch of new packages *but does not update*
    # the vulnerable one.

    new_pkgs = FactoryGirl.create_list(:ruby_package, 3)
    updated_pkgs = [vuln_pkg] + new_pkgs

    # this matters because the BM only sees {name, version}
    @bm.update(bundle.id, 
               updated_pkgs.map { |p| {name: p.name, version: p.version}})

    # the vulnerability has not changed, therefore only one LogBundleVuln
    assert_equal 1, bundle.vulnerable_packages.count
    assert_equal 1, LogBundleVulnerability.count

    # let's assert that the LBV is recording the right things
    log = LogBundleVulnerability.first
    assert_equal bundle.id, log.bundle_id
    assert_equal vuln_pkg.id, log.package_id
    assert_equal BundledPackage.where(:bundle_id => bundle.id,
                                      :package_id => vuln_pkg.id).pluck(:id)[0], log.bundled_package_id

    assert_equal vuln.id, log.vulnerability_id
    assert_equal VulnerablePackage.where(:package_id => vuln_pkg.id).pluck(:id)[0], log.vulnerable_package_id

    # OK, great. We now know that if we update the bundle with the same
    # package twice, we don't get multiple logs.
    #
    # What if we reset the bundle and re-add the offending package?
    # thereby triggering a new BundledPackage id?
  
    bundle.bundled_packages.delete_all
    assert_equal 0, bundle.packages.count

    @bm.update(bundle.id, 
               updated_pkgs.map { |p| {name: p.name, version: p.version}})

    # we now see another LBV.
    assert_equal 2, LogBundleVulnerability.count
    assert_equal vuln_pkg.id, LogBundleVulnerability.last.package_id

    # fabulous. This section was a separate test but I see no reason
    # not to include it in this scenario.
    

    # #############
    # SCENARIO TWO: 
    # A vulnerability that affects a package in the bundle
    # gets created.
    # #############

    # pick a package already associated with our bundle, from above:
    newly_vuln_pkg = updated_pkgs.last

    # mark it as vuln
    vuln_two = VulnerabilityManager.new.create(:package_name => newly_vuln_pkg.name,
                                               :package_platform => newly_vuln_pkg.platform,
                                               :patched_versions => ["> #{newly_vuln_pkg.version}"])

    # did we create another LBV?
    assert_equal 2, VulnerablePackage.count
    assert_equal 3, LogBundleVulnerability.where(:bundle_id => bundle.id).count

    second_log = LogBundleVulnerability.last

    assert_equal vuln_two.id, second_log.vulnerability_id


    # ###############
    # SCENARIO THREE:
    # A bundle gets updated with a vulnerable package
    # ###############


    vuln_three_pkg = FactoryGirl.create(:ruby_package)
    vuln_three = FactoryGirl.create(:ruby_vulnerability, :packages => [vuln_three_pkg])

    assert_equal 3, VulnerablePackage.count

    @bm.update(bundle.id, [vuln_three_pkg].map { |pkg|
      {name: pkg.name, version: pkg.version}
    })

    assert_equal 4, LogBundleVulnerability.where(:bundle_id => bundle.id).count
  end


end
