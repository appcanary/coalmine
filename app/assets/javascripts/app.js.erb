// sets up stuff required for the rest of the app to load.

window.Canary = {}
Canary.components = {};
Canary.controllers = {};
Canary.models = {};

Canary.mixins = {};

Canary.mixins.RefNodeMixin = {
  refnode: function(ref) {
    return React.findDOMNode(this.refs[ref]);
  }
}

Backbone.RailsModel = Backbone.Model.extend({
  toJSON: function() {
    json = {};
    json[this.rootKey] = Backbone.Model.prototype.toJSON.call(this);
    return json;
  },

  parse: function(json) {
    if(this.rootKey === undefined) {
      throw "root_key not defined on model";
    }

    if(json !== undefined) {
      return json[this.rootKey];
    }
  },

  fromForm: function(form) {
    var data = $(form).serializeArray();
    var formData = _.object(_.pluck(data, 'name'), _.pluck(data, 'value'));

    return this.set(formData);
  },

  setErrors: function(attr) {
    // there's a bug in here where .full_messages might not get set.
    // aka what to do on bad responses with no errors?
    // needs to handle 'attributes' obj
    this.errors = attr || {};
    if(this.errors.full_messages === undefined) {
      this.errors.full_messages = [];
    }

    this.trigger('error');
    return this.errors;
  }
})

Flux.Dispatcher.prototype.register_action = function(actions) {

  return this.register(function(payload) {
    var callback = actions[payload.actionType];

    if (callback !== undefined) {
      callback(payload);
    }
  });
}

Canary.Herald = new Flux.Dispatcher();

// Our own controller object, copying stuff from how Backbone.Model is setup.

Canary.Controller = function() {
    this.initialize.apply(this, arguments);
};

_.extend(Canary.Controller.prototype, Backbone.Events, {
  redirect_to: function(path) {
    $("#main").velocity("transition.fadeOut", function() {
      React.unmountComponentAtNode(document.getElementById("main"));
      $("#main").velocity({opacity: 1}, { display: 'inherit'})
      Canary.Navigator.navigate(path, {trigger: true});
    });
  },
})

Canary.Controller.extend = Backbone.Model.extend;

