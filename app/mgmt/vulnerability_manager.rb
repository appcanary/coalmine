class VulnerabilityManager
  def create(proto_vuln)
    vuln = Vulnerability.new(proto_vuln)
    vuln.transaction do
      unless vuln.save
        raise "vuln problem, deal w/later somehow"
      end

      vuln = update_affected_packages!(vuln)
    end

    vuln
  end

  def update(vuln_id, attr)
    vuln = Vulnerability.find(vuln_id)
    vuln.transaction do

      # TODO: figure out consistent way
      # to deal with error objects
      vuln.update_attributes!(attr)
      update_affected_packages!(vuln)
    end
  end

  def update_affected_packages!(vuln)
    concerned_packages = vuln.concerned_packages
    affected_packages = concerned_packages.select do |package|
      vuln.affects?(package)
    end

    # TODO: transaction :D
    vuln.packages = affected_packages

    ReportManager.new.on_vulnerability_change(vuln.id)

    vuln
  end

  # gets called only when new packages are created.

  # this doesn't have to trigger a report because:
  # a report will be triggered when the package gets
  # assigned to a bundle. 
  #
  # there should not be a scenario where this method
  # gets called, on packages that are in a bundle
  # without triggering the bundle update report
  def update_affecting_vulnerabilities!(possible_vulns, package)
    possible_vulns.select do |vuln|
      if vuln.affects?(package)
        # TODO: vulnlog? handle diff?
        vuln.packages << package
      end
    end
  end
end
