class VulnerabilityManager < ServiceManager
  attr_accessor :platform, :initial_import
  def initialize(platform, initial_import = false)
    self.platform = platform
    self.initial_import = initial_import
  end

  def create(advisory)
    vuln = Vulnerability.new(advisory.to_vuln_attributes)

    constraints = advisory.constraints
    begin
      vuln.transaction do
        vuln.save!
        assign_dependencies!(vuln, constraints)

        unless initial_import
          update_affected_packages!(vuln)
        end

        vuln.advisories += [advisory]
        advisory.advisory_import_state.update_attributes!(processed: true)
        
      end
    rescue ActiveRecord::RecordInvalid => e
      return Result.new(vuln, e)
    end

    return Result.new(vuln)
  end

  def update(vuln, advisory)
    vattr = advisory.to_vuln_attributes

    constraints = advisory.constraints

    begin
      vuln.transaction do
        vuln.update_attributes!(vattr)
        assign_dependencies!(vuln, constraints)
        update_affected_packages!(vuln)
        advisory.advisory_import_state.update_attributes!(processed: true)
        
      end
    rescue ActiveRecord::RecordInvalid => e
      return Result.new(vuln, e)
    end

    return Result.new(vuln)
  end

  def assign_dependencies!(vuln, proto_vds)
    vuln_deps = proto_vds.map { |h| 
      h[:platform] = @platform
      VulnerableDependency.new(h).tap { |vd| 
        vd.vulnerability = vuln
        vd.validate! 
      }
    }

    # When we assign a collection to the vulnerable_dependencies association, 
    # it triggers a deletion of existing vulnerable_deps not in the
    # new list. This will cascade and delete associated VPackages
    #
    # However not every VPkg might be invalid. By diffing, we ensure
    # we minimize the amount of preeixisting links we break.
    # i.e. reports

    new_deps = right_join_coll(vuln.vulnerable_dependencies, vuln_deps)
    vuln.vulnerable_dependencies = new_deps
  end


  def update_affected_packages!(vuln)
    # find packages that *could* be affected
    concerned_packages = vuln.concerned_packages

    # actually find the packages that are affected
    vuln_packages = concerned_packages.reduce([]) do |array, package|
      vds = vuln.select_affected_dependencies(package)
      vds.each do |vd|
        array << VulnerablePackage.new(:package => package,
                                       :vulnerable_dependency => vd,
                                       :vulnerability => vuln)
      end
      array
    end

    # figure out which ones we have yet to assign
    new_vuln_packages = right_join_coll(vuln.vulnerable_packages, vuln_packages)
    vuln.vulnerable_packages = new_vuln_packages

    ReportMaker.new.on_vulnerability_change(vuln.id)

    vuln
  end

  # compare items in existing and submitted,
  # and return all new and intersecting VDs
  # 
  # for intersecting items, return those from
  # the 'existing' list rather than the fresh
  # items in 'submitted'.
  def right_join_coll(existing, submitted)
    existing_set = existing.reduce({}) { |h, k|
      h[k.unique_hash] = k
      h
    }

    submitted_set = {}
    submitted.reduce([]) { |selection, newk|
      # have we seen this before? skip, forget dupes
      if submitted_set[newk.unique_hash]
        selection
      else
        submitted_set[newk.unique_hash] = newk
        # is there a newk in the old set? if so
        # we probably want that object instead.
        if (existing_dep = existing_set[newk.unique_hash]).nil?
          selection << newk
        else
          selection << existing_dep
        end

        selection
      end
    }
  end
end
