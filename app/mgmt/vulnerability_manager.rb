class VulnerabilityManager < ServiceManager
  attr_accessor :platform, :initial_import
  def initialize(platform, initial_import = false)
    self.platform = platform
    self.initial_import = initial_import
  end

  def create(advisory)
    vuln = Vulnerability.new(advisory.to_vuln_attributes)

    constraints = advisory.constraints
    begin
      vuln.transaction do
        vuln.save!
        assign_dependencies!(vuln, constraints)

        unless initial_import
          update_affected_packages!(vuln)
        end

        vuln.advisories += [advisory]
        advisory.advisory_import_state.update_attributes!(processed: true)
      end
    rescue ActiveRecord::RecordInvalid => e
      return Result.new(vuln, e)
    end

    return Result.new(vuln)
  end

  def update(vuln, advisory)
    vattr = advisory.to_vuln_attributes

    constraints = advisory.constraints

    begin
      vuln.transaction do
        # We touch :updated_at here because we want to trigger the archive even
        # if we didn't change anything on the model, only the vulnerable
        # dependencies. Calling touch always will trigger two archives if we
        # actually changed the model setting :touch => true on the
        # VulnerableDependency model will trigger a separate archive for every
        # vuln dep that's added, not one per transaction
        vuln.assign_attributes(vattr.merge(:updated_at => Time.now))
        vuln.assign_max_criticality
        vuln.save!

        assign_dependencies!(vuln, constraints)
        update_affected_packages!(vuln)
        advisory.advisory_import_state.update_attributes!(processed: true)
      end
    rescue ActiveRecord::RecordInvalid => e
      return Result.new(vuln, e)
    end

    return Result.new(vuln)
  end

  def assign_dependencies!(vuln, proto_vds)
    vuln_deps = proto_vds.map { |h| 
      h[:platform] = @platform
      VulnerableDependency.new(h).tap { |vd| 
        vd.vulnerability = vuln
        vd.validate! 
      }
    }

    # When we assign a collection to the vulnerable_dependencies association, 
    # it triggers a deletion of existing vulnerable_deps not in the
    # new list. This will cascade and delete associated VPackages
    #
    # However not every VPkg might be invalid. By diffing, we ensure
    # we minimize the amount of preeixisting links we break.
    # i.e. reports

    cur_deps = right_join_coll(vuln.vulnerable_dependencies, vuln_deps)

    vuln.vulnerable_dependencies = cur_deps

    # ok, right_join_coll will ignore pending and end_of_life
    # so we need to loop thru things one more time and assign
    # those variables

    assign_flags!(cur_deps, vuln_deps)
  end


  def update_affected_packages!(vuln)
    # find packages that *could* be affected
    concerned_packages = vuln.concerned_packages

    # actually find the packages that are affected
    vuln_packages = concerned_packages.reduce([]) do |array, package|
      vds = vuln.select_affected_dependencies(package)
      vds.each do |vd|
        array << VulnerablePackage.new(:package => package,
                                       :vulnerable_dependency => vd,
                                       :vulnerability => vuln)
      end
      array
    end

    # figure out which ones we have yet to assign
    new_vuln_packages = right_join_coll(vuln.vulnerable_packages, vuln_packages)
    vuln.vulnerable_packages = new_vuln_packages

    ReportMaker.new.on_vulnerability_change(vuln.id)

    vuln
  end

  # compare items in existing and submitted,
  # and return all new and intersecting VDs
  # 
  # for intersecting items, return those from
  # the 'existing' list rather than the fresh
  # items in 'submitted'.
  def right_join_coll(existing, submitted)
    existing_set = {} 
    existing.each do |k|
      existing_set[k.unique_hash] = k
    end

    submitted_set = {}
    submitted.reduce([]) { |selection, newk|
      # have we seen this before? skip, forget dupes
      if submitted_set[newk.unique_hash]
        selection
      else
        submitted_set[newk.unique_hash] = newk
        # is there a newk in the old set? if so
        # we probably want that object instead.
        if (existing_dep = existing_set[newk.unique_hash]).nil?
          selection << newk
        else
          selection << existing_dep
        end

        selection
      end
    }
  end

  # if an item in new_deps exists in cur_deps,
  # update new_deps item with the pending & eolife
  # flag values from new_deps.
  #
  # alas easiest way to do this is mutate state.
  def assign_flags!(cur_deps, new_deps)
    existing_set = {}
    cur_deps.each { |cur_vd|
      existing_set[cur_vd.unique_hash] = cur_vd
    }

    new_deps.each do |new_vd|
      if cur_vd = existing_set[new_vd.unique_hash]
        cur_vd.pending = new_vd.pending
        cur_vd.end_of_life = new_vd.end_of_life
        cur_vd.save!
      end
    end
  end
end
