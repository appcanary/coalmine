class VulnerabilityManager < ServiceManager
  attr_accessor :package_platform
  def initialize(platform)
    self.package_platform = platform
  end
  def create(proto_vuln, proto_vds)
    proto_vuln[:package_platform] = @package_platform
    vuln = Vulnerability.new(proto_vuln)

    begin
      vuln.transaction do
        vuln.save!
        assign_dependencies!(vuln, proto_vds)
        update_affected_packages!(vuln)
      end
    rescue ActiveRecord::RecordInvalid => e
      return Result.new(vuln, e)
    end

    return Result.new(vuln)
  end

  def update(vuln_id, vattr, vds)
    vuln = Vulnerability.find(vuln_id)

    begin
      vuln.transaction do
        vuln.update_attributes!(vattr)
        assign_dependencies!(vuln, vds)
        update_affected_packages!(vuln)
      end
    rescue ActiveRecord::RecordInvalid => e
      return Result.new(vuln, e)
    end

    return Result.new(vuln)
  end

  def assign_dependencies!(vuln, proto_vds)
    vuln_deps = proto_vds.map { |h| 
      h[:package_platform] = @package_platform
      VulnerableDependency.new(h).tap { |vd| 
        vd.vulnerability = vuln
        vd.validate! 
      }
    }

    # When we assign a collection to the vulnerable_dependencies association, 
    # it triggers a deletion of existing vulnerable_deps not in the
    # new list. This will cascade and delete associated VPackages
    #
    # However not every VPkg might be invalid. By diffing, we ensure
    # we minimize the amount of preeixisting links we break.
    # i.e. reports

    new_deps = right_join_coll(vuln.vulnerable_dependencies, vuln_deps)
    vuln.vulnerable_dependencies = new_deps
  end


  def update_affected_packages!(vuln)
    concerned_packages = vuln.concerned_packages

    vuln_packages = concerned_packages.reduce([]) do |array, package|
      vds = vuln.affected_dependencies(package)
      vds.each do |vd|
        array << VulnerablePackage.new(:package => package,
                                       :vulnerable_dependency => vd,
                                       :vulnerability => vuln)
      end
      array
    end

    new_vuln_packages = right_join_coll(vuln.vulnerable_packages, vuln_packages)
    vuln.vulnerable_packages = new_vuln_packages

    ReportMaker.new.on_vulnerability_change(vuln.id)

    vuln
  end

  # compare items in existing and submitted,
  # and return all new and intersecting VDs
  # 
  # for intersecting items, return those from
  # the 'existing' list rather than the fresh
  # items in 'submitted'.
  def right_join_coll(existing, submitted)
    existing_set = existing.reduce({}) { |h, k|
      h[k.unique_hash] = k
      h
    }

    submitted_set = {}
    submitted.reduce([]) { |selection, newk|
      # have we seen this before? skip, forget dupes
      if submitted_set[newk.unique_hash]
        selection
      else
        submitted_set[newk.unique_hash] = newk
        # is there a newk in the old set? if so
        # we probably want that object instead.
        if (existing_dep = existing_set[newk.unique_hash]).nil?
          selection << newk
        else
          selection << existing_dep
        end

        selection
      end
    }
  end
end
