# takes unprocessed advisories
# and converts them to Vulnerabilities
#
# ensure one exception doesn't halt every importer
class VulnerabilityImporter
  include ResultObject
  IMPORTERS =  [CesaImporter,
                RubysecImporter,
                FriendsOfPHPImporter,
                DebianTrackerImporter, 
                UbuntuTrackerImporter, 
                AlasImporter,
                AlpineImporter]

  class VulnerabilityImportError < StandardError
    def initialize(adv, error)
      super("Error: advisory ##{adv.id} - #{error}")
    end
  end

  # used for dev testing
  def self.really_everything!
    IMPORTERS.each do |k|
      begin
        k.new.import!
      rescue => e
        binding.pry
        # report to sentry or w/e
      end
      res, errors = self.new(k::PLATFORM, k::SOURCE).import
      if errors.present?
        binding.pry
        # report to sentry or w/e
      end
    end
  end


  def initialize(platform, source)
    @platform = platform
    @source = source

    if [@platform, @source].any?(&:blank?)
      raise ArgumentError.new("Neither platform nor source may be empty")
    end
    
    @vm = VulnerabilityManager.new(@platform)
  end

  def import
    @errors = []
    Advisory.where(:source => @source).unprocessed.find_each do |adv|

      if adv.vulnerabilities.present?
        # simple case:
        # this vuln derived from a single advisory
        # therefore, just blanket update the constraints
        # unless we manually edited the vuln's fields.
        #
        # so: always update the constraints, check 
        # remaining attributes. maybe add a flag to vulns.
        #
        # more complex case: 
        # we grab package info from Debian's ST, and 
        # vuln description from DSAs.
        # how do we know what fields to update then?

        # TODO: 1 vulnerability has many Advs but Adv has one?
        # so fuck it, remember to fix this in migration
        adv.vulnerabilities.each do |vuln|

          v, error = @vm.update(vuln, adv)
          if error.present? 
            @errors << VulnerabilityImportError.new(adv, error)
          end
        end

      else
        vuln, error = @vm.create(adv)
        if error.present?
          @errors << VulnerabilityImportError.new(adv, error)
        end
      end
    end

    if @errors.present?
      Result.new(nil, @errors)
    else
      Result.new(true, nil)
    end
  end
end
