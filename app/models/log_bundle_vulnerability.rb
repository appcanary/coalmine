# == Schema Information
#
# Table name: log_bundle_vulnerabilities
#
#  id                       :integer          not null, primary key
#  bundle_id                :integer          not null
#  package_id               :integer          not null
#  bundled_package_id       :integer          not null
#  vulnerability_id         :integer          not null
#  vulnerable_dependency_id :integer          not null
#  vulnerable_package_id    :integer          not null
#  occurred_at              :datetime         not null
#  created_at               :datetime         not null
#  updated_at               :datetime         not null
#

class LogBundleVulnerability < ActiveRecord::Base
  belongs_to :bundle
  belongs_to :package
  belongs_to :bundled_package
  belongs_to :vulnerability
  belongs_to :vulnerable_package

  
  # give me all the LBVs that we have not recorded a patch for
  scope :unpatched_vuln_logs, -> {
    where('NOT EXISTS 
           (SELECT 1 FROM "log_bundle_patches" lbp WHERE
             lbp.bundle_id = "log_bundle_vulnerabilities".bundle_id AND
             lbp.package_id = "log_bundle_vulnerabilities".package_id AND
             lbp.bundled_package_id = "log_bundle_vulnerabilities".bundled_package_id AND
             lbp.vulnerability_id = "log_bundle_vulnerabilities".vulnerability_id AND
             lbp.vulnerable_dependency = "log_bundle_vulnerabilities".vulnerable_dependency_id AND
             lbp.vulnerable_package_id = "log_bundle_vulnerabilities".vulnerable_package_id)')
  }

  # Every time a bundle is changed, note whether 
  # the bundle is vulnerable at that point in time.
  #
  # We create a log instance whenever: 
  # 1. A bundle gets created w/vuln packages
  # 2. Vulnerability that affects a package in bundle gets created
  # 3. A package that is vulnerable gets added to the bundle.

  # TODO lol optimize
  def self.record_vulnerability!(vuln_id)
    bundled_packages = BundledPackage.select_log_joins_vulns.
      where_lbv_not_already_logged.
      where('"vulnerable_packages".vulnerability_id = ?', vuln_id)
      
    bundled_packages.each do |bun|
      self.create(:bundle_id => bun.bundle_id,
                  :package_id => bun.package_id,
                  :bundled_package_id => bun.bundled_package_id,
                  :vulnerability_id => vuln_id,
                  :vulnerable_dependency_id => bun.vulnerable_dependency_id,
                  :vulnerable_package_id => bun.vulnerable_package_id,
                  :occurred_at => bun.occurred_at)
    end
  end

  # TODO lol optimize
  def self.record_bundle_vulnerabilities!(bundle_id)
    # get all the bundled packages that have vulnerabilities
    # for a given bundle, that we haven't recorded yet
    bundled_packages = BundledPackage.select_log_joins_vulns.
      where_lbv_not_already_logged.
      where(:bundle_id => bundle_id)
     
     bundled_packages.each do |bun|
       self.create(:bundle_id => bun.bundle_id,
                   :package_id => bun.package_id,
                   :bundled_package_id => bun.bundled_package_id,
                   :vulnerability_id => bun.vulnerability_id,
                   :vulnerable_dependency_id => bun.vulnerable_dependency_id,
                   :vulnerable_package_id => bun.vulnerable_package_id,
                   :occurred_at => bun.occurred_at)
     end
  end

end
