# == Schema Information
#
# Table name: log_bundle_vulnerabilities
#
#  id                       :integer          not null, primary key
#  bundle_id                :integer          not null
#  package_id               :integer          not null
#  bundled_package_id       :integer          not null
#  vulnerability_id         :integer          not null
#  vulnerable_dependency_id :integer          not null
#  vulnerable_package_id    :integer          not null
#  supplementary            :boolean          default("false"), not null
#  occurred_at              :datetime         not null
#  created_at               :datetime         not null
#  updated_at               :datetime         not null
#
# Indexes
#
#  index_log_bundle_vulnerabilities_on_bundle_id                 (bundle_id)
#  index_log_bundle_vulnerabilities_on_bundled_package_id        (bundled_package_id)
#  index_log_bundle_vulnerabilities_on_package_id                (package_id)
#  index_log_bundle_vulnerabilities_on_vulnerability_id          (vulnerability_id)
#  index_log_bundle_vulnerabilities_on_vulnerable_dependency_id  (vulnerable_dependency_id)
#  index_log_bundle_vulnerabilities_on_vulnerable_package_id     (vulnerable_package_id)
#  index_of_six_kings_LBV                                        (bundle_id,package_id,bundled_package_id,vulnerability_id,vulnerable_dependency_id,vulnerable_package_id) UNIQUE
#

# Creates historical record of when a bundle has been 
# associated with a vulnerability, and how.
#
# The supplementary flag tracks whether the change was
# initiated by the system (i.e. new or changed vulnerability)
# or by the user (i.e. bundle packages were changed).
class LogBundleVulnerability < ActiveRecord::Base
  belongs_to :bundle
  belongs_to :package
  belongs_to :bundled_package
  belongs_to :vulnerability
  belongs_to :vulnerable_dependency
  belongs_to :vulnerable_package

  has_many :notifications

  # we want all LBVs that point to:
  # 1. vuln_deps that currently exist (i.e. not since deleted)
  # 2. bundles that currently exist
  # 3. that have NOT already been put into a notification
  
  scope :unnotified_logs, -> {
    joins(:vulnerable_dependency).
    joins(:bundle).
    joins('LEFT JOIN "notifications" ON "notifications".log_bundle_vulnerability_id = "log_bundle_vulnerabilities".id').
    where('"notifications".id IS NULL')
  }

  scope :patchable, -> {
    current_scope.merge(VulnerableDependency.patchable)
  }

  scope :select_distinct_pkg, -> {
    select("distinct(log_bundle_vulnerabilities.package_id)")
  }

  scope :in_bundles_from, -> (account_id) {
    @previously_saved_account_id = sanitize(account_id)
    joins("INNER JOIN 
          (SELECT id, agent_server_id FROM bundles WHERE bundles.account_id = #{@previously_saved_account_id}) bundles ON 
          bundles.id = log_bundle_vulnerabilities.bundle_id").select("log_bundle_vulnerabilities.*").select("bundles.agent_server_id")
  }

  # todo: document
  scope :that_are_unpatched, -> {
    joins("LEFT JOIN log_bundle_patches ON 
          log_bundle_patches.bundle_id = log_bundle_vulnerabilities.bundle_id AND
          log_bundle_patches.bundled_package_id = log_bundle_vulnerabilities.bundled_package_id AND
          log_bundle_patches.package_id = log_bundle_vulnerabilities.package_id AND
          log_bundle_patches.vulnerability_id = log_bundle_vulnerabilities.vulnerability_id AND
          log_bundle_patches.vulnerable_dependency_id = log_bundle_vulnerabilities.vulnerable_dependency_id AND
          log_bundle_patches.vulnerable_package_id = log_bundle_vulnerabilities.vulnerable_package_id").
          where('"log_bundle_patches".id IS NULL')
  }

  # we look inside the log bundle patches,
  # and ensure there is no equivalent for this particular
  # LBV (left join ... id is NULL
  # and we scope it to vuln_deps issued before date
  # i.e as of THIS DATE it remains unpatched
  scope :unpatched_as_of, -> (end_at) {
    joins(:vulnerable_dependency).
    joins("LEFT JOIN log_bundle_patches ON 
          log_bundle_patches.bundle_id = log_bundle_vulnerabilities.bundle_id AND
          log_bundle_patches.bundled_package_id = log_bundle_vulnerabilities.bundled_package_id AND
          log_bundle_patches.package_id = log_bundle_vulnerabilities.package_id AND
          log_bundle_patches.vulnerability_id = log_bundle_vulnerabilities.vulnerability_id AND
          log_bundle_patches.vulnerable_dependency_id = log_bundle_vulnerabilities.vulnerable_dependency_id AND
          log_bundle_patches.vulnerable_package_id = log_bundle_vulnerabilities.vulnerable_package_id AND
          log_bundle_patches.occurred_at <= #{sanitize(end_at)}").
    where('"log_bundle_patches".id IS NULL').
    where("vulnerable_dependencies.valid_at <= ?", end_at)
  }

  scope :vulnerable_after, -> (begin_at) {
    joins(:vulnerable_dependency).
    where("vulnerable_dependencies.valid_at >= ?", begin_at)
  }

  
  scope :vulnerable_before, -> (begin_at) {
    joins(:vulnerable_dependency).
    where("vulnerable_dependencies.valid_at < ?", begin_at)
  }



  # deprecated?
  scope :vulnerable_between, -> (begin_at, end_at) {
    if @previously_saved_account_id.nil?
      raise "You must call `in_bundles_from` first!"
    end

    joins("INNER JOIN 
          (SELECT bundled_packages.* FROM bundled_packages INNER JOIN bundles ON bundles.id = bundled_packages.bundle_id WHERE bundles.account_id = #{@previously_saved_account_id}) bundled_packages ON
          bundled_packages.id = log_bundle_vulnerabilities.bundled_package_id").
    joins("INNER JOIN vulnerable_dependencies ON
          vulnerable_dependencies.id = log_bundle_vulnerabilities.vulnerable_dependency_id").
          where("(vulnerable_dependencies.created_at >= ? AND vulnerable_dependencies.created_at <= ?) OR
                (bundled_packages.created_at >= ? AND bundled_packages.created_at <= ?)", 
                begin_at, end_at, begin_at, end_at)
  }


  # Every time a bundle is changed, note whether 
  # the bundle is vulnerable at that point in time.
  #
  # We create a log instance whenever: 
  # 1. A bundle gets created w/vuln packages
  # 2. Vulnerability that affects a package in bundle gets created
  # 3. A package that is vulnerable gets added to the bundle.

  # TODO lol optimize
  # TODO OCCURRED AT SHOULD BE THE VULN PACKAGE CREATEDAT, i.e. like in LBP
  def self.record_vulnerability!(vuln_id)
    bundled_packages = BundledPackage.select_log_joins_vulns.
      where_lbv_not_already_logged.
      where('"vulnerable_packages".vulnerability_id = ?', vuln_id)
      
    bundled_packages.each do |bun|
      self.create(:bundle_id => bun.bundle_id,
                  :package_id => bun.package_id,
                  :bundled_package_id => bun.bundled_package_id,
                  :vulnerability_id => vuln_id,
                  :vulnerable_dependency_id => bun.vulnerable_dependency_id,
                  :vulnerable_package_id => bun.vulnerable_package_id,
                  :supplementary => true,
                  :occurred_at => bun.occurred_at)
    end
  end

  # TODO lol optimize
  def self.record_bundle_vulnerabilities!(bundle_id)
    # get all the bundled packages that have vulnerabilities
    # for a given bundle, that we haven't recorded yet
    bundled_packages = BundledPackage.select_log_joins_vulns.
      where_lbv_not_already_logged.
      where(:bundle_id => bundle_id)
     
     bundled_packages.each do |bun|
       self.create(:bundle_id => bun.bundle_id,
                   :package_id => bun.package_id,
                   :bundled_package_id => bun.bundled_package_id,
                   :vulnerability_id => bun.vulnerability_id,
                   :vulnerable_dependency_id => bun.vulnerable_dependency_id,
                   :vulnerable_package_id => bun.vulnerable_package_id,
                   :occurred_at => bun.occurred_at)
     end
  end

  def self.resolution_log_primary_key
    "log_bundle_vulnerabilities.package_id"
  end
end
