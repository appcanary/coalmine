# == Schema Information
#
# Table name: vulnerabilities
#
#  id            :integer          not null, primary key
#  platform      :string           not null
#  title         :string           not null
#  description   :text
#  criticality   :integer          default("0"), not null
#  reference_ids :string           default("{}"), not null, is an Array
#  related       :jsonb            default("[]"), not null
#  osvdb_id      :string
#  usn_id        :string
#  dsa_id        :string
#  rhsa_id       :string
#  cesa_id       :string
#  edited        :boolean          default("false")
#  source        :string
#  reported_at   :datetime
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  valid_at      :datetime         not null
#  expired_at    :datetime         default("infinity"), not null
#  package_names :string           default("{}"), not null, is an Array
#
# Indexes
#
#  index_vulnerabilities_on_criticality_and_reported_at  (criticality,reported_at)
#  index_vulnerabilities_on_expired_at                   (expired_at)
#  index_vulnerabilities_on_platform                     (platform)
#  index_vulnerabilities_on_valid_at                     (valid_at)
#

class Vulnerability < ActiveRecord::Base
  has_many :vulnerable_dependencies, :dependent => :destroy
  has_many :vulnerable_packages, :dependent => :destroy
  has_many :packages, :through => :vulnerable_packages

  has_many :advisory_vulnerabilities
  has_many :advisories, :through => :advisory_vulnerabilities

  has_one :vulnerability_search_index

  has_many :archives, :class_name => VulnerabilityArchive
  enum criticality: Advisory::CRITICALITIES

  scope :order_by_criticality, -> {
    order(criticality: :desc, reported_at: :desc)
  }

  scope :search, ->(query) {
    joins(:vulnerability_search_index).where("vulnerability_search_index.document @@ plainto_tsquery(?)", query)
  }

  # TODO: probably deprecated code? to delete.
  def affects?(package)
    self.affected_dependencies(package).any?  
  end

  def select_affected_dependencies(package)
    self.vulnerable_dependencies.lazy.select { |vd|
      vd.affects?(package)
    }
  end

  # TODO does this need an 
  # OR (source_name = package_name AND source_name is not null)?
  
  def concerned_packages()
    Package.joins('inner join vulnerable_dependencies vd on "packages".platform = vd.platform').where("name = package_name OR source_name = package_name").where("vulnerability_id = ?", self.id)
  end

  def criticality_ordinal
    self.attributes["criticality"]
  end

  def cve_ids
    self.reference_ids.select { |r| r.starts_with?("CVE") }
  end

  def cves
    Advisory.from_cve.where(:identifier => self.cve_ids)
  end

  def cvss
    self.cves.pluck(:cvss).max
  end

  def related_vulns
    Vulnerability.by_cve_ids(self.cve_ids) - [self]
  end

  def self.attribute_names
    self.column_names - ["id", "created_at", "updated_at", "valid_at", "expired_at"]
  end

  def self.max_criticality_ordinal
    # all here is the current scope, so when Vulnerability is scoped, this will work correctly.
    # i.e. Vulnerability.max_criticality_ordinal returns the max criticality (ordinal) across all vulns
    # some_package.vulnerabilities.max_criticality_ordinal returns the max criticality for that vuln collection
    # Note we get the ordinal here because we're plucking, so it doesn't get converted to a string
    all.reorder(nil).order_by_criticality.limit(1).pluck(:criticality)[0]
  end

  def self.by_cve_id(cve_id)
    where("? = ANY(reference_ids)", cve_id).order(:platform)
  end

  def self.by_cve_ids(cve_ids)
    where("ARRAY[?]::varchar[] && vulnerabilities.reference_ids", cve_ids).order(:platform)
  end


end
