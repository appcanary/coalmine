# == Schema Information
#
# Table name: vulnerabilities
#
#  id            :integer          not null, primary key
#  platform      :string           not null
#  title         :string
#  description   :text
#  criticality   :string
#  reference_ids :string           default("{}"), not null, is an Array
#  osvdb_id      :string
#  usn_id        :string
#  dsa_id        :string
#  rhsa_id       :string
#  cesa_id       :string
#  source        :string
#  reported_at   :datetime
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  valid_at      :datetime         not null
#  expired_at    :datetime         default("infinity"), not null
#
# Indexes
#
#  index_vulnerabilities_on_expired_at  (expired_at)
#  index_vulnerabilities_on_platform    (platform)
#  index_vulnerabilities_on_valid_at    (valid_at)
#

class Vulnerability < ActiveRecord::Base
  has_many :vulnerable_dependencies, :dependent => :destroy
  has_many :vulnerable_packages
  has_many :packages, :through => :vulnerable_packages

  has_many :advisory_vulnerabilities
  has_many :advisories, :through => :advisory_vulnerabilities

  def affects?(package)
    self.affected_dependencies(package).any?  
  end

  def select_affected_dependencies(package)
    self.vulnerable_dependencies.lazy.select { |vd|
      vd.affects?(package)
    }
  end

  # TODO does this need an 
  # OR (source_name = package_name AND source_name is not null)?
  
  def concerned_packages()
    Package.joins('inner join vulnerable_dependencies vd on "packages".platform = vd.platform').where("name = package_name OR source_name = package_name").where("vulnerability_id = ?", self.id)
  end

  def self.attribute_names
    self.column_names - ["id", "created_at", "updated_at", "valid_at", "expired_at"]
  end
end
